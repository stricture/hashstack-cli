package cmd

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"

	"github.com/stacktitan/boom"
)

type requestCreateError struct {
}

func (e *requestCreateError) Error() string {
	return "There was an error creating the request."
}

type requestError struct {
}

func (e *requestError) Error() string {
	return "There was an error completing the request. The server may not be available."
}

type invalidCertError struct {
}

func (e *invalidCertError) Error() string {
	return "There was an error while validating the server's TLS certificate. Consider using --insecure."
}

type authError struct {
}

func (e *authError) Error() string {
	return "The client failed to authenticate to the server. Try to login again."
}

type authorizeError struct {
}

func (e *authorizeError) Error() string {
	return "The server says that you are not authorized to complete this request."
}

type badRequestError struct {
	ServerMsg string
}

func (e *badRequestError) Error() string {
	return fmt.Sprintf("There were validation errors in your request that resulted in a 400 status code being returned from the server.\n\nServer Message: %s.\n", e.ServerMsg)
}

type notFoundError struct {
}

func (e *notFoundError) Error() string {
	return "The resource was not found on the server."
}

type internalServerError struct {
}

func (e *internalServerError) Error() string {
	return "There was an internal server error."
}

type invalidResponseError struct {
}

func (e *invalidResponseError) Error() string {
	return "An unexpected response from was sent from the server."
}

type jsonServerError struct {
}

func (e *jsonServerError) Error() string {
	return "The JSON returned from the server could not be parsed correctly."
}

type jsonClientError struct {
}

func (e *jsonClientError) Error() string {
	return "There was an error parsing the JSON generated by the client."
}

func respToError(resp *http.Response) error {
	switch resp.StatusCode {
	case 401:
		return new(authError)
	case 403:
		return new(authorizeError)
	case 400:
		data, err := ioutil.ReadAll(resp.Body)
		defer resp.Body.Close()
		e := new(badRequestError)
		if len(data) > 0 && err == nil {
			var output boom.Output
			if err := json.Unmarshal(data, &output); err != nil {
				e.ServerMsg = "No message was returned from the server!"
			} else {
				e.ServerMsg = output.Message
			}
		} else {
			e.ServerMsg = "No message was returned from the server!"
		}
		return e
	case 404:
		return new(notFoundError)
	case 500:
		return new(internalServerError)
	}
	return nil
}

func getTotal(path string) (int, error) {
	debug(fmt.Sprintf("HTTP: GET %s", path))

	var total int

	req, err := http.NewRequest("GET", fmt.Sprintf("%s%s", flServerURL, path), nil)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return total, new(requestCreateError)
	}
	req.Header.Set("Authorization", fmt.Sprintf("bearer %s", flToken))
	req.Header.Set("Range", "1-1")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		if strings.Contains(err.Error(), "x509") {
			return total, new(invalidCertError)
		}
		return total, new(requestError)
	}
	if err := respToError(resp); err != nil {
		return total, err
	}
	contentRange := resp.Header.Get("Content-Range")
	if contentRange == "" {
		return total, new(invalidResponseError)
	}
	parts := strings.Split(contentRange, "/")
	if len(parts) != 2 {
		return total, new(invalidResponseError)
	}
	total, err = strconv.Atoi(parts[1])
	if err != nil {
		return total, new(invalidResponseError)
	}
	return total, nil
}

func getRangeJSON(path string, data interface{}) error {
	debug(fmt.Sprintf("HTTP: GET %s", path))

	total, err := getTotal(path)
	if err != nil {
		return err
	}
	if total < 1 {
		return nil
	}
	req, err := http.NewRequest("GET", fmt.Sprintf("%s%s", flServerURL, path), nil)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return new(requestCreateError)
	}
	req.Header.Set("Range", fmt.Sprintf("1-%d", total))
	req.Header.Set("Authorization", fmt.Sprintf("bearer %s", flToken))
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		if strings.Contains(err.Error(), "x509") {
			return new(invalidCertError)
		}
		return new(requestError)
	}
	if err := respToError(resp); err != nil {
		return err
	}
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return new(invalidResponseError)
	}
	if err := json.Unmarshal(body, data); err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return new(jsonServerError)
	}
	return nil
}

func getReader(path string) (io.ReadCloser, error) {
	debug(fmt.Sprintf("HTTP: GET %s", path))

	req, err := http.NewRequest("GET", fmt.Sprintf("%s%s", flServerURL, path), nil)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return nil, new(requestCreateError)
	}
	req.Header.Set("Authorization", fmt.Sprintf("bearer %s", flToken))
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		if strings.Contains(err.Error(), "x509: x509") {
			return nil, new(invalidCertError)
		}
		return nil, new(requestError)
	}
	if err := respToError(resp); err != nil {
		return nil, err
	}
	return resp.Body, nil
}

func getJSON(path string, data interface{}) error {
	debug(fmt.Sprintf("HTTP: GET %s", path))

	req, err := http.NewRequest("GET", fmt.Sprintf("%s%s", flServerURL, path), nil)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return new(requestCreateError)
	}
	req.Header.Set("Accept", "application/json")
	req.Header.Set("Authorization", fmt.Sprintf("bearer %s", flToken))
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		if strings.Contains(err.Error(), "x509: x509") {
			return new(invalidCertError)
		}
		return new(requestError)
	}
	if err := respToError(resp); err != nil {
		return err
	}
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return new(invalidResponseError)
	}
	if err := json.Unmarshal(body, data); err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return new(jsonServerError)
	}
	return nil
}

func postJSON(path string, data interface{}) ([]byte, error) {
	debug(fmt.Sprintf("HTTP: POST %s", path))

	var body []byte
	buff, err := json.Marshal(data)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return body, new(jsonClientError)
	}
	req, err := http.NewRequest("POST", fmt.Sprintf("%s%s", flServerURL, path), bytes.NewBuffer(buff))
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return body, new(requestCreateError)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", fmt.Sprintf("bearer %s", flToken))
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		if strings.Contains(err.Error(), "x509: x509") {
			return nil, new(invalidCertError)
		}
		return body, new(requestError)
	}
	if err := respToError(resp); err != nil {
		return body, err
	}
	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return body, new(invalidResponseError)
	}
	return body, nil
}

func patchJSON(path string, data interface{}) ([]byte, error) {
	debug(fmt.Sprintf("HTTP: PATCH %s", path))

	var body []byte
	buff, err := json.Marshal(data)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return body, new(jsonClientError)
	}
	req, err := http.NewRequest("PATCH", fmt.Sprintf("%s%s", flServerURL, path), bytes.NewBuffer(buff))
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return body, new(requestCreateError)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", fmt.Sprintf("bearer %s", flToken))
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		if strings.Contains(err.Error(), "x509: x509") {
			return nil, new(invalidCertError)
		}
		return body, new(requestError)
	}
	if err := respToError(resp); err != nil {
		return body, err
	}
	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return body, new(invalidResponseError)
	}
	return body, nil
}

func postMultipart(path, contentType string, reader io.Reader) ([]byte, error) {
	debug(fmt.Sprintf("HTTP: POST %s", path))

	var body []byte
	req, err := http.NewRequest("POST", fmt.Sprintf("%s%s", flServerURL, path), reader)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return body, new(requestCreateError)
	}
	req.Header.Set("Content-Type", contentType)
	req.Header.Set("Authorization", fmt.Sprintf("bearer %s", flToken))
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		if strings.Contains(err.Error(), "x509: x509") {
			return nil, new(invalidCertError)
		}
		return body, new(requestError)
	}
	if err := respToError(resp); err != nil {
		return body, err
	}
	body, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return body, new(invalidResponseError)
	}
	return body, nil
}

func deleteHTTP(path string) error {
	debug(fmt.Sprintf("HTTP: DELETE %s", path))

	req, err := http.NewRequest("DELETE", fmt.Sprintf("%s%s", flServerURL, path), nil)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		return new(requestCreateError)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", fmt.Sprintf("bearer %s", flToken))
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		debug(fmt.Sprintf("Error: %s", err.Error()))
		if strings.Contains(err.Error(), "x509") {
			return new(invalidCertError)
		}
		return new(requestError)
	}
	if err := respToError(resp); err != nil {
		return err
	}
	return nil
}
